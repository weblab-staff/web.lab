export const tabs = [
  {
    name: "utilities.js",
    code: `/**\n * Utility functions to make API requests.\n * By importing this file, you can use the provided get and post functions.\n * You shouldn\'t need to modify this file, but if you want to learn more\n * about how these functions work, google search \"Fetch API\"\n *\n * These functions return promises, which means you should use \".then\" on them.\n * e.g. get(\'/api/foo\', { bar: 0 }).then(res => console.log(res))\n */\n\n// ex: formatParams({ some_key: \"some_value\", a: \"b\"}) => \"some_key=some_value&a=b\"\nfunction formatParams(params) {\n  // iterate of all the keys of params as an array,\n  // map it to a new array of URL string encoded key,value pairs\n  // join all the url params using an ampersand (&).\n  return Object.keys(params)\n    .map((key) => key + \"=\" + encodeURIComponent(params[key]))\n    .join(\"&\");\n}\n\n// convert a fetch result to a JSON object with error handling for fetch and json errors\nfunction convertToJSON(res) {\n  if (!res.ok) {\n    throw \`API request failed with response status \${res.status} and text: \${res.statusText}\`;\n  }\n\n  return res\n    .clone() // clone so that the original is still readable for debugging\n    .json() // start converting to JSON object\n    .catch((error) => {\n      // throw an error containing the text that couldn\'t be converted to JSON\n      return res.text().then((text) => {\n        throw \`API request\'s result could not be converted to a JSON object: \\n\${text}\`;\n      });\n    });\n}\n\n// Helper code to make a get request. Default parameter of empty JSON Object for params.\n// Returns a Promise to a JSON Object.\nexport function get(endpoint, params = {}) {\n  const fullPath = endpoint + \"?\" + formatParams(params);\n  return fetch(fullPath)\n    .then(convertToJSON)\n    .catch((error) => {\n      // give a useful error message\n      throw \`GET request to \${fullPath} failed with error:\\n\${error}\`;\n    });\n}\n\n// Helper code to make a post request. Default parameter of empty JSON Object for params.\n// Returns a Promise to a JSON Object.\nexport function post(endpoint, params = {}) {\n  return fetch(endpoint, {\n    method: \"post\",\n    headers: { \"Content-type\": \"application/json\" },\n    body: JSON.stringify(params),\n  })\n    .then(convertToJSON) // convert result to JSON object\n    .catch((error) => {\n      // give a useful error message\n      throw \`POST request to \${endpoint} failed with error:\\n\${error}\`;\n    });\n}`,
    lang: "js",
  },
  {
    name: "utilities.css",
    code: '/**\n* Welcome to your âœ¨ğ”²ğ”±ğ”¦ğ”©ğ”¦ğ”±ğ”¶ ğ”°ğ”±ğ”¶ğ”©ğ”¢ğ”°âœ¨!\n* This file includes utility classes that are super simple\n* and can be used to add general styles; variable definitions\n* for colors; and styles to html, body, and other high level\n* DOMs.\n* \n* All utility classes start with a `u-` and all do\n* one basic CSS thing (for example, making the font-weight\n* 600 for bolding) or are super generic.\n* \n* This is ğ™‰ğ™Šğ™ the place to define classes for components or\n* do rigorous styling. You shoud not need to change this file\n* much after initial creation.\n*/\n\n@import url("https://fonts.googleapis.com/css?family=Open+Sans:300,600");\n\n:root {\n  --primary: #396dff;\n  --primary--dim: #6987db;\n  --darkgrey: #d4d4d4;\n  --medgrey: #e0e0e0;\n  --grey: #f7f7f7;\n  --white: #fff;\n\n  --xs: 4px;\n  --s: 8px;\n  --m: 16px;\n  --l: 24px;\n}\n\nbody {\n  margin: 0;\n  padding: 0;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 300;\n}\n\nform {\n  flex-grow: 1;\n}\n\n.u-flex {\n  display: flex;\n}\n\n.u-flexColumn {\n  display: flex;\n  flex-direction: column;\n}\n\n.u-flex-justifyCenter {\n  justify-content: center;\n}\n\n.u-flex-alignCenter {\n  align-items: center;\n}\n\n.u-inlineBlock {\n  display: inline-block;\n}\n\n.u-bold {\n  font-weight: 600;\n}\n\n.u-textCenter {\n  text-align: center;\n}\n\n.u-relative {\n  position: relative;\n}\n\n.u-pointer {\n  cursor: pointer;\n}\n\n.u-link {\n  color: var(--primary);\n  text-decoration: none;\n  cursor: pointer;\n}\n\n.u-link:hover {\n  color: var(--primary--dim);\n}',
    lang: "css",
  },
  {
    name: "index.js",
    code: `import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./components/App.js\";\n\n// renders React Component \"Root\" into the DOM element with ID \"root\"\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// allows for live updating\nmodule.hot.accept();`,
    lang: "js",
  },
  {
    name: "canvasManager.js",
    code: `let canvas;\n\n/** utils */\n\n// load sprites!\nlet sprites = {\n  red: null,\n  blue: null,\n  green: null,\n  yellow: null,\n  purple: null,\n  orange: null,\n  silver: null,\n};\nObject.keys(sprites).forEach((key) => {\n  sprites[key] = new Image(400, 400);\n  sprites[key].src = \`../player-icons/\${key}.png\`; // Load sprites from dist folder\n});\n\n// converts a coordinate in a normal X Y plane to canvas coordinates\nconst convertCoord = (x, y) => {\n  if (!canvas) return;\n  return {\n    drawX: x,\n    drawY: canvas.height - y,\n  };\n};\n\n// fills a circle at a given x, y canvas coord with radius and color\nconst fillCircle = (context, x, y, radius, color) => {\n  context.beginPath();\n  context.arc(x, y, radius, 0, 2 * Math.PI, false);\n  context.fillStyle = color;\n  context.fill();\n};\n\n// draws a sprite instead of a colored circle\nconst drawSprite = (context, x, y, radius, color) => {\n  context.save();\n  // Saves current context so we can restore to here once we are done drawing\n  context.beginPath();\n  context.arc(x, y, radius, 0, 2 * Math.PI, false);\n  context.closePath();\n  context.clip(); // Sets circular clipping region for sprite image\n  context.drawImage(sprites[color], x - radius, y - radius, radius * 2, radius * 2);\n  context.restore();\n  // Restores context to last save (before clipping was applied), so we can draw normally again\n};\n\n/** drawing functions */\n\nconst drawPlayer = (context, x, y, radius, color) => {\n  const { drawX, drawY } = convertCoord(x, y);\n  drawSprite(context, drawX, drawY, radius, color);\n};\n\nconst drawCircle = (context, x, y, radius, color) => {\n  const { drawX, drawY } = convertCoord(x, y);\n  fillCircle(context, drawX, drawY, radius, color);\n};\n\n/** main draw */\nexport const drawCanvas = (drawState) => {\n  // use id of canvas element in HTML DOM to get reference to canvas object\n  canvas = document.getElementById(\"game-canvas\");\n  if (!canvas) return;\n  const context = canvas.getContext(\"2d\");\n\n  // clear the canvas to black\n  context.fillStyle = \"black\";\n  context.fillRect(0, 0, canvas.width, canvas.height);\n\n  // draw all the players\n  Object.values(drawState.players).forEach((p) => {\n    drawPlayer(context, p.position.x, p.position.y, p.radius, p.color);\n  });\n\n  // draw all the foods\n  Object.values(drawState.food).forEach((f) => {\n    drawCircle(context, f.position.x, f.position.y, f.radius, f.color);\n  });\n};`,
    lang: "js",
  },
];
